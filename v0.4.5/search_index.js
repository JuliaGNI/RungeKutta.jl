var documenterSearchIndex = {"docs":
[{"location":"radauIIA/#Radau-IIA-Runge-Kutta-Methods","page":"Radau IIA Methods","title":"Radau-IIA Runge-Kutta Methods","text":"","category":"section"},{"location":"radauIIA/","page":"Radau IIA Methods","title":"Radau IIA Methods","text":"Runge-Kutta Tableau RadauIIA(2) with 2 stages and order 3: Error: TypeError: in keyword argument backend, expected Union{Val{:auto}, Val{:text}, Val{:html}, Val{:latex}}, got a value of type Symbol","category":"page"},{"location":"radauIA/#Radau-IA-Runge-Kutta-Methods","page":"Radau IA Methods","title":"Radau-IA Runge-Kutta Methods","text":"","category":"section"},{"location":"radauIA/","page":"Radau IA Methods","title":"Radau IA Methods","text":"Runge-Kutta Tableau RadauIA(2) with 2 stages and order 3: Error: TypeError: in keyword argument backend, expected Union{Val{:auto}, Val{:text}, Val{:html}, Val{:latex}}, got a value of type Symbol","category":"page"},{"location":"rungekutta/#Runge-Kutta-Methods","page":"Runge-Kutta Methods","title":"Runge-Kutta Methods","text":"","category":"section"},{"location":"rungekutta/","page":"Runge-Kutta Methods","title":"Runge-Kutta Methods","text":"Runge-Kutta methods exploit the Fundamental Theorem of Calculus, which states that the solution of an initial-value problem","category":"page"},{"location":"rungekutta/","page":"Runge-Kutta Methods","title":"Runge-Kutta Methods","text":"beginaligned\ndotx (t) = f(t x(t))  \nx(t_n) = x_n \nendaligned","category":"page"},{"location":"rungekutta/","page":"Runge-Kutta Methods","title":"Runge-Kutta Methods","text":"at time t_n+1 is given by","category":"page"},{"location":"rungekutta/","page":"Runge-Kutta Methods","title":"Runge-Kutta Methods","text":"x (t_n+1) = x (t_n) + int limits_t_n^t_n+1 dotx (t)  dt ","category":"page"},{"location":"rungekutta/","page":"Runge-Kutta Methods","title":"Runge-Kutta Methods","text":"Runge-Kutta methods are constructed by approximating the integral by some quadrature formula with s nodes c_i and corresponding weights b_i to obtain x_n+1 approx x (t_n+1) by","category":"page"},{"location":"rungekutta/","page":"Runge-Kutta Methods","title":"Runge-Kutta Methods","text":"beginaligned\nx_n+1 = x_n + h sum limits_i=1^s b_i dotX_ni  \ndotX_ni = f(t_n + c_i h X_ni) \nendaligned","category":"page"},{"location":"rungekutta/","page":"Runge-Kutta Methods","title":"Runge-Kutta Methods","text":"where the internal stage values X_ni approx x(t_n + c_i h) for i = 1  s are determined by another quadrature formula, approximating the integral","category":"page"},{"location":"rungekutta/","page":"Runge-Kutta Methods","title":"Runge-Kutta Methods","text":"x(t_n + c_i h) = x (t_n) + int limits_t_n^t_n + c_i h dotx (t)  dt ","category":"page"},{"location":"rungekutta/","page":"Runge-Kutta Methods","title":"Runge-Kutta Methods","text":"namely","category":"page"},{"location":"rungekutta/","page":"Runge-Kutta Methods","title":"Runge-Kutta Methods","text":"X_ni = x_n + h sum limits_j=1^s a_ij dotX_nj ","category":"page"},{"location":"rungekutta/","page":"Runge-Kutta Methods","title":"Runge-Kutta Methods","text":"with the same vector field values dotX_nj used for the computation of x_n+1.","category":"page"},{"location":"rungekutta/","page":"Runge-Kutta Methods","title":"Runge-Kutta Methods","text":"Definition: Runge-Kutta methods are numerical one-step methods","category":"page"},{"location":"rungekutta/","page":"Runge-Kutta Methods","title":"Runge-Kutta Methods","text":"beginaligned\nX_ni = x_n + h sum limits_j=1^s a_ij  f(t_n + c_j h X_nj)  \nx_n+1 = x_n + h sum limits_j=1^s b_j   f(t_n + c_j h X_nj) \nendaligned","category":"page"},{"location":"rungekutta/","page":"Runge-Kutta Methods","title":"Runge-Kutta Methods","text":"defined by a set of nodes c_i, weights b_i and coefficients a_ij with ij = 1  s, summarized in the Butcher tableau","category":"page"},{"location":"rungekutta/","page":"Runge-Kutta Methods","title":"Runge-Kutta Methods","text":"beginarraycc\nc  a     \nhline\n   b^T \nendarray\n=\nbeginarrayccccc\nc_1   a_11  a_12  dots  a_1s \nc_2   a_21  a_22  dots  a_2s \nvdots  vdots  vdots  ddots  vdots \nc_s   a_s1  a_s2  dots  a_ss \nhline\n        b_1   b_2   dots  b_s  \nendarray","category":"page"},{"location":"rungekutta/","page":"Runge-Kutta Methods","title":"Runge-Kutta Methods","text":"Most properties of the methods, such as order or stability, can be analysed just by posing conditions on the Butcher tableau.","category":"page"},{"location":"rungekutta/#Simplifying-Assumptions","page":"Runge-Kutta Methods","title":"Simplifying Assumptions","text":"","category":"section"},{"location":"rungekutta/","page":"Runge-Kutta Methods","title":"Runge-Kutta Methods","text":"The construction of many Runge-Kutte methods, in particular the Gauß, Radau and Lobatto methods, relies on the so-called simplifying assumptions:","category":"page"},{"location":"rungekutta/","page":"Runge-Kutta Methods","title":"Runge-Kutta Methods","text":"beginaligned\nB(sigma)  sum limits_i=1^s b_i c_i^k-1 = frac1k  \nk = 1      sigma  \n\nC(eta)  sum limits_j=1^s a_ij c_j^k-1 = fracc_i^kk  \ni = 1     s   k = 1      eta  \n\nD(zeta)  sum limits_i=1^s b_i c_i^k-1 a_ij = fracb_jk ( 1 - c_j^k )  \nj = 1     s   k = 1      zeta \nendaligned","category":"page"},{"location":"rungekutta/","page":"Runge-Kutta Methods","title":"Runge-Kutta Methods","text":"These assumptions provide order conditions for a Runge-Kutta method given by (a_ij b_i c_i). The condition B(p) implies that the quadrature rule (b_i c_i) is of order p. Furthermore, the following theorem holds:","category":"page"},{"location":"rungekutta/","page":"Runge-Kutta Methods","title":"Runge-Kutta Methods","text":"Theorem (Butcher 1964): If the coefficients (a_ij b_i c_i) of a Runge-Kutta method satisfy B(sigma), C(eta), D(zeta) with sigma le eta + zeta + 1 and sigma le 2 eta + 2, then the method is of order sigma.","category":"page"},{"location":"rungekutta/#Gauß,-Lobatto-and-Radau-Methods","page":"Runge-Kutta Methods","title":"Gauß, Lobatto and Radau Methods","text":"","category":"section"},{"location":"rungekutta/","page":"Runge-Kutta Methods","title":"Runge-Kutta Methods","text":"Gauß methods are collocation methods using the nodes and weights of Gaußian quadrature formulas. The nodes are the zeros of the shifted Legendre polynomials of degree s,","category":"page"},{"location":"rungekutta/","page":"Runge-Kutta Methods","title":"Runge-Kutta Methods","text":"fracd^sdx^s big( x^s (x-1)^s big) ","category":"page"},{"location":"rungekutta/","page":"Runge-Kutta Methods","title":"Runge-Kutta Methods","text":"In a similar fashion, the nodes of the Radau I and II and the Lobatto III methods are defined as the roots of the polynomials","category":"page"},{"location":"rungekutta/","page":"Runge-Kutta Methods","title":"Runge-Kutta Methods","text":"beginaligned\n fracd^s-1dx^s-1 big( x^s (x-1)^s-1 big)      text(Radau I)  \n fracd^s-1dx^s-1 big( x^s-1 (x-1)^s big)      text(Radau II)  \n fracd^s-2dx^s-2 big( x^s-1 (x-1)^s-1 big)  text(Lobatto III) \nendaligned","category":"page"},{"location":"rungekutta/","page":"Runge-Kutta Methods","title":"Runge-Kutta Methods","text":"The weights b_1  b_s are chosen such that the methods satisfy B(sigma), that is B(s), for the Gauß methods, B(s-1) for the Radau methods, and B(s-2) for the Lobatto methods.","category":"page"},{"location":"rungekutta/","page":"Runge-Kutta Methods","title":"Runge-Kutta Methods","text":"The coefficients a_ij for ij = 1  s are obtained by the simplifying assumption C(s) for the Gauß, Radau IIA and Lobatto IIIA methods, and by the simplifying assumption D(s) for the Radau IA and Lobatto IIIB methods. The coefficients of the Lobatto IIIC methods are determined by setting a_i1 = b_1 for i = 1  s and solving the simplifying assumption C(s-1), while the coefficients of the Lobatto IIIC̄ methods are determined by setting a_is = 0 and solving C(s-1). Note that the Lobatto IIIC̄ methods are sometimes also called Lobatto III or Lobatto III*. For reasons of code symmetry we chose to stick with the less common name Lobatto IIIC̄. The Lobatto IIID and IIIE methods are obtained by combining the tableaus of the Lobatto IIIC and IIIC̄ and the Lobatto IIIA and IIIB methods, respectively, i.e., ","category":"page"},{"location":"rungekutta/","page":"Runge-Kutta Methods","title":"Runge-Kutta Methods","text":"beginaligned\na_ij^D = tfrac12 ( a_ij^C + a_ij^C ) \n textand \na_ij^E = tfrac12 ( a_ij^A + a_ij^B ) \nendaligned","category":"page"},{"location":"rungekutta/","page":"Runge-Kutta Methods","title":"Runge-Kutta Methods","text":"While the Lobatto IIIA, IIIB, IIIC and IIIC̄ methods are not symplectic on their own (although the Lobatto IIIA-IIIB and IIIC-IIIC̄ pairs constitute symplectic partitioned Runge-Kutta methods), the Lobatto IIID and IIIE methods are each symplectic by themselves.","category":"page"},{"location":"rungekutta/","page":"Runge-Kutta Methods","title":"Runge-Kutta Methods","text":"The Gauß methods are of order 2s, the Radau methods or order 2s-1 and the Lobatto methods are of order 2s-2, with the exception of the Lobatto IIIF method. This method has been specifically constructed to be of order 2s as described in [Wang Fangzong, Liao Xiaobing (2016)]. The Lobatto IIIG method is constructed in a similar fashion as the Lobatto IIID and IIIE methods by averaging the coefficients of the Lobatto IIIF method with its symplectic complement, i.e.,","category":"page"},{"location":"rungekutta/","page":"Runge-Kutta Methods","title":"Runge-Kutta Methods","text":"a_ij^G = tfrac12 ( a_ij^F + bara_ij^F ) ","category":"page"},{"location":"rungekutta/","page":"Runge-Kutta Methods","title":"Runge-Kutta Methods","text":"where the coffiecients bara_ij^F are determined by","category":"page"},{"location":"rungekutta/","page":"Runge-Kutta Methods","title":"Runge-Kutta Methods","text":"beginaligned\nb_i bara^F_ij + barb_j a^F_ji = b_i barb_j  \n textand \nbarb_i = b_i \nendaligned","category":"page"},{"location":"rungekutta/","page":"Runge-Kutta Methods","title":"Runge-Kutta Methods","text":"The tableaus of all of the above methods can be computed for an arbitrary number of stages s and thus to arbitrary order.","category":"page"},{"location":"diagnostics/#Diagnostics","page":"Diagnostics","title":"Diagnostics","text":"","category":"section"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"Currently, diagnostic functions for checking symmetry, symplecticity and the so-called simplifying assumptions are implemented:","category":"page"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"issymmetric(tab)\nissymplectic(tab)\nsatisfies_simplifying_assumption_b(tab, σ=tab.s)\nsatisfies_simplifying_assumption_c(tab, σ=tab.s)\nsatisfies_simplifying_assumption_d(tab, σ=tab.s)","category":"page"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"This list is expected to grow in the near future.","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"CurrentModule = RungeKutta","category":"page"},{"location":"library/#Runge-Kutta-Library-Functions","page":"Library","title":"Runge Kutta Library Functions","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [RungeKutta, RungeKutta.Tableaus, RungeKutta.PartitionedTableaus]","category":"page"},{"location":"library/#RungeKutta.PartitionedTableau","page":"Library","title":"RungeKutta.PartitionedTableau","text":"Tableau of a Partitioned Runge-Kutta method\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a_ij  v(t_n + c_j Delta t Q_nj P_nj)  \nq_n+1 = q_n + h sum limits_i=1^s b_i   v(t_n + c_j Delta t Q_ni P_ni)  \nP_ni = p_n + h  sum limits_i=1^s bara_ij  f(t_n + c_j Delta t Q_nj P_nj)  \np_n+1 = p_n + h sum limits_i=1^s barb_i    f(t_n + c_j Delta t Q_ni P_ni) \nendaligned\n\nParameters:\n\nT: datatype of coefficient arrays\n\nFields:\n\nname: symbolic name of the tableau\no: order of the method\ns: number of stages\nq: Tableau for q\np: Tableau for p\nR∞: stability function at infinity\n\nThe actual tableaus are stored in q and p:\n\na: coefficients a_ij with $ 1 \\le i,j \\le s$\nb: weights b_i  with $ 1 \\le i \\le s$\nc: nodes c_i  with $ 1 \\le i \\le s$\n\nConstructors:\n\nPartitionedTableau{T}(name, o, q, p)\nPartitionedTableau{T}(name, q, p)\nPartitionedTableau(name::Symbol, q::Tableau, p::Tableau)\nPartitionedTableau(name::Symbol, q::Tableau)\n\n\n\n\n\n","category":"type"},{"location":"library/#RungeKutta.Tableau","page":"Library","title":"RungeKutta.Tableau","text":"Holds the tableau of a Runge-Kutta method\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a_ij  v(t_n + c_j Delta t Q_nj)  \nq_n+1 = q_n + h sum limits_i=1^s b_i   v(t_n + c_j Delta t Q_ni)  \nendaligned\n\nParameters:\n\nT: datatype of coefficient arrays\n\nFields:\n\nname: symbolic name of the tableau\no: order of the method\ns: number of stages\na: coefficients a_ij with $ 1 \\le i,j \\le s$\nb: weights b_i  with $ 1 \\le i \\le s$\nc: nodes c_i  with $ 1 \\le i \\le s$\nR∞: stability function at infinity\n\nConstructors:\n\nTableau{T}(name, o, s, a, b, c)\nTableau{T}(name, o, a, b, c)\nTableau(name::Symbol, o::Int, s::Int, a::AbstractMatrix, b::AbstractVector, c::AbstractVector)\nTableau(name::Symbol, o::Int, a::AbstractMatrix, b::AbstractVector, c::AbstractVector)\nTableau(name::Symbol, o::Int, t::AbstractMatrix)\n\nThe last constructor accepts an (s+1) times (s+1) array that holds the whole tableau in the form of a Butcher tableau, i.e.,\n\nc a\n b\n\n\n\n\n\n","category":"type"},{"location":"library/#Base.show-Tuple{IO, MIME{Symbol(\"text/markdown\")}, Tableau}","page":"Library","title":"Base.show","text":"Base.show(io::IO, ::MIME\"text/markdown\", tab::Tableau)\n\nGenerate and print a nice markdown table for the Runge-Kutta tableau.\n\n\n\n\n\n","category":"method"},{"location":"library/#Base.show-Tuple{IO, Tableau}","page":"Library","title":"Base.show","text":"Base.show(io::IO, tab::Tableau)\n\nPretty-print Runge-Kutta tableau.\n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.SymplecticPartitionedTableau-Tuple{Tableau}","page":"Library","title":"RungeKutta.SymplecticPartitionedTableau","text":"SymplecticPartitionedTableau(tab::Tableau)\n\nGenerates a partitioned tableau with tab and ist symplectic adjoint.\n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.SymplecticTableau-Tuple{Tableau}","page":"Library","title":"RungeKutta.SymplecticTableau","text":"SymplecticTableau(tab::Tableau)\n\nGenerates a new tableau with symplectizied coefficients.\n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta._legendre-Union{Tuple{T}, Tuple{Int64, T}} where T","page":"Library","title":"RungeKutta._legendre","text":"Legendre polynomial P_s(x) of degree s defined on the interval [-1..+1].\n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta._shifted_legendre","page":"Library","title":"RungeKutta._shifted_legendre","text":"Legendre polynomial of degree s shifted to the interval [0..1], i.e., P_s(2x-1).\n\n\n\n\n\n","category":"function"},{"location":"library/#RungeKutta.from_file-Tuple{AbstractString, AbstractString}","page":"Library","title":"RungeKutta.from_file","text":"from_file(dir::AbstractString, name::AbstractString)\n\nRead Runge-Kutta tableau from the file <name>.tsv in the directory dir.\n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.solve_simplifying_assumption_b-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T","page":"Library","title":"RungeKutta.solve_simplifying_assumption_b","text":"Compute the weights by solving the simplifying assumption B(s):\n\nsum limits_j=1^s b_j c_j^k-1 = frac1k  qquad k = 1      s \n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.solve_simplifying_assumption_c-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T","page":"Library","title":"RungeKutta.solve_simplifying_assumption_c","text":"Compute the coefficients by solving the simplifying assumption C(s):\n\nsum limits_j=1^s a_ij c_j^k-1 = fracc_i^kk  qquad i = 1      s   k = 1      s \n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.solve_simplifying_assumption_d-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T","page":"Library","title":"RungeKutta.solve_simplifying_assumption_d","text":"Compute the coefficients by solving the simplifying assumption D(s):\n\nsum limits_i=1^s b_i c_i^k-1 a_ij = fracb_jk ( 1 - c_j^k)  qquad j = 1      s   k = 1      s \n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.to_file-Union{Tuple{T}, Tuple{AbstractString, Tableau{T}}} where T","page":"Library","title":"RungeKutta.to_file","text":"to_file(dir::AbstractString, tab::Tableau)\n\nWrite Runge-Kutta tableau to the file <tab.name>.tsv in the directory dir.\n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.Tableaus.TableauBackwardEuler","page":"Library","title":"RungeKutta.Tableaus.TableauBackwardEuler","text":"Alias for TableauImplicitEuler\n\n\n\n\n\n","category":"function"},{"location":"library/#RungeKutta.Tableaus.TableauCrankNicolson-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Library","title":"RungeKutta.Tableaus.TableauCrankNicolson","text":"Tableau of Crank-Nicolson two-stage, 2nd order method\n\nTableauCrankNicolson(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nJ. Crank and P. Nicolson.\nA practical method for numerical evaluation of solutions of partial differential equations of the heat-conduction type.\nMathematical Proceedings of the Cambridge Philosophical Society, Volume 43, Issue 1, Pages 50-67, 1947.\ndoi: 10.1017/S0305004100023197\n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.Tableaus.TableauCrouzeix-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Library","title":"RungeKutta.Tableaus.TableauCrouzeix","text":"Tableau of Crouzeix's two-stage, 3rd order method\n\nTableauCrouzeix(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nM.Crouzeix.\nSur L'approximation des équations différentielles opérationelles linéaires par des méthodes de Runge-Kutta.\nThesis. Université de Paris, 1975.\n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.Tableaus.TableauExplicitEuler-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Library","title":"RungeKutta.Tableaus.TableauExplicitEuler","text":"Tableau of one-stage, 1st order explicit (forward) Euler method\n\nTableauExplicitEuler(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nLeonhard Euler.\nInstitutiones calculi differentialis cum eius vsu in analysi finitorum ac doctrina serierum.\nImp. Acad. Imper. Scient. Petropolitanae, Opera Omnia, Vol.X, [I.6], 1755.\nIn: Opera Omnia, 1st Series, Volume 11, Institutiones Calculi Integralis. Teubner, Leipzig, Pages 424-434, 1913.\nSectio secunda. Caput VII. De integratione aequationum differentialium per approximationem. Problema 85.\n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.Tableaus.TableauExplicitMidpoint-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Library","title":"RungeKutta.Tableaus.TableauExplicitMidpoint","text":"Tableau of explicit two-stage, 2nd order midpoint method\n\nTableauExplicitMidpoint(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nCarl Runge.\nÜber die numerische Auflösung von Differentialgleichungen.\nMathematische Annalen, Volume 46, Pages 167-178, 1895.\ndoi: 10.1007/BF01446807.\nEquation (2)\n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.Tableaus.TableauForwardEuler","page":"Library","title":"RungeKutta.Tableaus.TableauForwardEuler","text":"Alias for TableauExplicitEuler\n\n\n\n\n\n","category":"function"},{"location":"library/#RungeKutta.Tableaus.TableauGauss-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Library","title":"RungeKutta.Tableaus.TableauGauss","text":"Gauss tableau with s stages\n\nTableauGauss(::Type{T}, s)\nTableauGauss(s) = TableauGauss(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nReferences:\n\nJohn C. Butcher.\nImplicit Runge-Kutta processes.\nMathematics of Computation, Volume 18, Pages 50-64, 1964.\ndoi: 10.1090/S0025-5718-1964-0159424-9.\n\nJohn C. Butcher.\nGauss Methods. \nIn: Engquist B. (eds). Encyclopedia of Applied and Computational Mathematics. Springer, Berlin, Heidelberg. 2015.\ndoi: 10.1007/978-3-540-70529-1_115.\n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.Tableaus.TableauHeun2-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Library","title":"RungeKutta.Tableaus.TableauHeun2","text":"Tableau of Heun's two-stage, 2nd order method\n\nTableauHeun2(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nKarl Heun.\nNeue Methoden zur approximativen Integration der Differentialgleichungen einer unabhängigen Veränderlichen.\nZeitschrift für Mathematik und Physik, Volume 45, Pages 23-38, 1900.\nAlgorithm II.\n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.Tableaus.TableauHeun3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Library","title":"RungeKutta.Tableaus.TableauHeun3","text":"Tableau of Heun's three-stage, 3rd order method\n\nTableauHeun3(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nKarl Heun.\nNeue Methoden zur approximativen Integration der Differentialgleichungen einer unabhängigen Veränderlichen.\nZeitschrift für Mathematik und Physik, Volume 45, Pages 23-38, 1900.\nAlgorithm VI.\n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.Tableaus.TableauImplicitEuler-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Library","title":"RungeKutta.Tableaus.TableauImplicitEuler","text":"Tableau of one-stage, 1st order implicit (backward) Euler method\n\nTableauImplicitEuler(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nAugustin-Louis Cauchy.\nÉquations différentielles ordinaires. Cours inédit (fragment). Douzième leçon.\nEd. Christian Gilain, Etudes Vivantes, 1981.\nPage 102, Equation (5), Θ=1.\n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.Tableaus.TableauImplicitMidpoint-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Library","title":"RungeKutta.Tableaus.TableauImplicitMidpoint","text":"Tableau of two-stage, 2nd order implicit midpoint method\n\nTableauImplicitMidpoint(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nAugustin-Louis Cauchy.\nÉquations différentielles ordinaires. Cours inédit (fragment). Douzième leçon.\nEd. Christian Gilain, Etudes Vivantes, 1981.\nPage 102, Equation (5), Θ=1/2.\n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.Tableaus.TableauKraaijevangerSpijker-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Library","title":"RungeKutta.Tableaus.TableauKraaijevangerSpijker","text":"Tableau of Kraaijevanger and Spijker's two-stage, 2nd order method\n\nTableauKraaijevangerSpijker(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nJ. F. B. M. Kraaijevanger and M. N. Spijker.\nAlgebraic stability and error propagation in Runge-Kutta methods.\nApplied Numerical Mathematics, Volume 5, Issues 1-2, Pages 71-87, 1989.\ndoi: 10.1016/0168-9274(89)90025-1\n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.Tableaus.TableauKutta-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Library","title":"RungeKutta.Tableaus.TableauKutta","text":"Tableau of Kutta's three-stage, 3rd order method\n\nTableauKutta(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nWilhelm Kutta\nBeitrag zur Näherungsweisen Integration totaler Differentialgleichungen\nZeitschrift für Mathematik und Physik, Volume 46, Pages 435–453, 1901.\nPage 440\n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.Tableaus.TableauKutta3","page":"Library","title":"RungeKutta.Tableaus.TableauKutta3","text":"Alias for TableauKutta\n\n\n\n\n\n","category":"function"},{"location":"library/#RungeKutta.Tableaus.TableauLobattoIIIA-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Library","title":"RungeKutta.Tableaus.TableauLobattoIIIA","text":"Lobatto IIIA tableau with s stages\n\nTableauLobattoIIIA(::Type{T}, s)\nTableauLobattoIIIA(s) = TableauLobattoIIIA(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nReferences:\n\nByron Leonard Ehle\nOn Padé approximations to the exponential function and a-stable methods for the numerical solution of initial value problems.\nResearch Report CSRR 2010, Dept. AACS, University of Waterloo, 1969.\n\nLaurent O. Jay.\nLobatto Methods.\nIn: Engquist B. (eds). Encyclopedia of Applied and Computational Mathematics. Springer, Berlin, Heidelberg. 2015.\ndoi: 10.1007/978-3-540-70529-1_123\n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.Tableaus.TableauLobattoIIIB-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Library","title":"RungeKutta.Tableaus.TableauLobattoIIIB","text":"Lobatto IIIB tableau with s stages\n\nTableauLobattoIIIB(::Type{T}, s)\nTableauLobattoIIIB(s) = TableauLobattoIIIB(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nReferences:\n\nByron Leonard Ehle.\nOn Padé approximations to the exponential function and a-stable methods for the numerical solution of initial value problems.\nResearch Report CSRR 2010, Dept. AACS, University of Waterloo, 1969.\n\nLaurent O. Jay.\nLobatto Methods.\nIn: Engquist B. (eds). Encyclopedia of Applied and Computational Mathematics. Springer, Berlin, Heidelberg. 2015.\ndoi: 10.1007/978-3-540-70529-1_123.\n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.Tableaus.TableauLobattoIIIB̄-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Library","title":"RungeKutta.Tableaus.TableauLobattoIIIB̄","text":"Lobatto IIIB̄ tableau with s stages\n\nTableauLobattoIIIB̄(::Type{T}, s)\nTableauLobattoIIIB̄(s) = TableauLobattoIIIB̄(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nLobatto IIIB̄ tableau is the conjugate symplectic to TableauLobattoIIIB. On paper, its coefficients are identical to TableauLobattoIIIA, however, they are computed by the symplecticity condition and not by the formula for Lobatto IIIA and thus the numerical values are slightly different.\n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.Tableaus.TableauLobattoIIIC-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Library","title":"RungeKutta.Tableaus.TableauLobattoIIIC","text":"Lobatto IIIC tableau with s stages\n\nTableauLobattoIIIC(::Type{T}, s)\nTableauLobattoIIIC(s) = TableauLobattoIIIC(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nReferences:\n\nF. H. Chipman.\nA-stable Runge-Kutta processes.\nBIT, Volume 11, Pages 384-388, 1971.\ndoi: 10.1007/BF01939406.\n\nLaurent O. Jay.\nLobatto Methods.\nIn: Engquist B. (eds). Encyclopedia of Applied and Computational Mathematics. Springer, Berlin, Heidelberg. 2015.\ndoi: 10.1007/978-3-540-70529-1_123.\n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.Tableaus.TableauLobattoIIIC̄-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Library","title":"RungeKutta.Tableaus.TableauLobattoIIIC̄","text":"Lobatto IIIC̄ tableau with s stages\n\nTableauLobattoIIIC̄(::Type{T}, s)\nTableauLobattoIIIC̄(s) = TableauLobattoIIIC̄(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nReferences:\n\nJohn C. Butcher.\nIntegration processes based on Radau quadrature formulas\nMathematics of Computation, Volume 18, Pages 233-244, 1964.\ndoi: 10.1090/S0025-5718-1964-0165693-1.\n\nLaurent O. Jay.\nLobatto Methods.\nIn: Engquist B. (eds). Encyclopedia of Applied and Computational Mathematics. Springer, Berlin, Heidelberg. 2015.\ndoi: 10.1007/978-3-540-70529-1_123.\n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.Tableaus.TableauLobattoIIID-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Library","title":"RungeKutta.Tableaus.TableauLobattoIIID","text":"Lobatto IIID tableau with s stages\n\nTableauLobattoIIID(::Type{T}, s)\nTableauLobattoIIID(s) = TableauLobattoIIID(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nReferences:\n\nR.P.K. Chan.\nOn symmetric Runge-Kutta methods of high order.\nComputing, Volume 45, Pages 301-309, 1990.\ndoi: 10.1007/BF02238798\n\nLaurent O. Jay.\nLobatto Methods.\nIn: Engquist B. (eds). Encyclopedia of Applied and Computational Mathematics. Springer, Berlin, Heidelberg. 2015.\ndoi: 10.1007/978-3-540-70529-1_123.\n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.Tableaus.TableauLobattoIIID̄-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Library","title":"RungeKutta.Tableaus.TableauLobattoIIID̄","text":"Lobatto IIID̄ tableau with s stages\n\nTableauLobattoIIID̄(::Type{T}, s)\nTableauLobattoIIID̄(s) = TableauLobattoIIID̄(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nLobatto IIID̄ tableau is the conjugate symplectic to TableauLobattoIIID. On paper, the coefficients of the Lobatto IIID tableau are symplectic, however, the Lobatto IIID̄ coefficients are computed by the symplecticity condition and not by the formula for Lobatto IIID and thus the numerical values are slightly different.\n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.Tableaus.TableauLobattoIIIE-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Library","title":"RungeKutta.Tableaus.TableauLobattoIIIE","text":"Lobatto IIIE tableau with s stages\n\nTableauLobattoIIIE(::Type{T}, s)\nTableauLobattoIIIE(s) = TableauLobattoIIIE(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nReferences:\n\nR.P.K. Chan.\nOn symmetric Runge-Kutta methods of high order.\nComputing, Volume 45, Pages 301-309, 1990.\ndoi: 10.1007/BF02238798\n\nLaurent O. Jay.\nLobatto Methods.\nIn: Engquist B. (eds). Encyclopedia of Applied and Computational Mathematics. Springer, Berlin, Heidelberg. 2015.\ndoi: 10.1007/978-3-540-70529-1_123.\n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.Tableaus.TableauLobattoIIIF-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Library","title":"RungeKutta.Tableaus.TableauLobattoIIIF","text":"Lobatto IIIF tableau with s stages\n\nTableauLobattoIIIF(::Type{T}, s)\nTableauLobattoIIIF(s) = TableauLobattoIIIF(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nReferences:\n\nWang Fangzong and Liao Xiaobing.\nA Class of Lobatto Methods of Order 2s.\nJournal of Applied Mathematics, Volume 46, Pages 6-10, 2016.\n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.Tableaus.TableauLobattoIIIF̄-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Library","title":"RungeKutta.Tableaus.TableauLobattoIIIF̄","text":"Lobatto IIIF̄ tableau with s stages\n\nTableauLobattoIIIF̄(::Type{T}, s)\nTableauLobattoIIIF̄(s) = TableauLobattoIIIF̄(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nThe Lobatto IIIF̄ tableau is the conjugate symplectic to TableauLobattoIIIF.\n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.Tableaus.TableauLobattoIIIG-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Library","title":"RungeKutta.Tableaus.TableauLobattoIIIG","text":"Lobatto IIIG tableau with s stages\n\nTableauLobattoIIIG(::Type{T}, s)\nTableauLobattoIIIG(s) = TableauLobattoIIIG(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nSymplectizied algorithm for TableauLobattoIIIF\n\nCoefficients are taken as a^G = frac12 ( a^F + bara^F ) where the coefficients bara^F are computed such that the symplecticity conditions b_i bara_ij + barb_j a_ji = b_i barb_j and b_i = barb_i hold for all 1 le ij le s.\n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.Tableaus.TableauLobattoIIIĀ-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Library","title":"RungeKutta.Tableaus.TableauLobattoIIIĀ","text":"Lobatto IIIĀ tableau with s stages\n\nTableauLobattoIIIĀ(::Type{T}, s)\nTableauLobattoIIIĀ(s) = TableauLobattoIIIĀ(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nLobatto IIIĀ tableau is the conjugate symplectic to TableauLobattoIIIA. On paper, its coefficients are identical to TableauLobattoIIIB, however, they are computed by the symplecticity condition and not by the formula for Lobatto IIIB and thus the numerical values are slightly different.\n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.Tableaus.TableauLobattoIIIĒ-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Library","title":"RungeKutta.Tableaus.TableauLobattoIIIĒ","text":"Lobatto IIIĒ tableau with s stages\n\nTableauLobattoIIIĒ(::Type{T}, s)\nTableauLobattoIIIĒ(s) = TableauLobattoIIIĒ(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nLobatto IIIĒ tableau is the conjugate symplectic to TableauLobattoIIIE. On paper, the coefficients of the Lobatto IIIE tableau are symplectic, however, the Lobatto IIIĒ coefficients are computed by the symplecticity condition and not by the formula for Lobatto IIIE and thus the numerical values are slightly different.\n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.Tableaus.TableauLobattoIIIḠ-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Library","title":"RungeKutta.Tableaus.TableauLobattoIIIḠ","text":"Lobatto IIIḠ tableau with s stages\n\nTableauLobattoIIIḠ(::Type{T}, s)\nTableauLobattoIIIḠ(s) = TableauLobattoIIIḠ(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nLobatto IIIḠ tableau is the conjugate symplectic to TableauLobattoIIIG. On paper, the coefficients of the Lobatto IIIG tableau are symplectic, however, the Lobatto IIIḠ coefficients are computed by the symplecticity condition and not by the formula for Lobatto IIIG and thus the numerical values are slightly different.\n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.Tableaus.TableauQinZhang-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Library","title":"RungeKutta.Tableaus.TableauQinZhang","text":"Tableau of Qin and Zhang's symplectic two-stage, 2nd order method\n\nTableauQinZhang(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nM.-Z. Qin and M.-Q. Zhang.\nSymplectic Runge-Kutta algorithms for Hamilton systems.\nJournal of Computational Mathematics, Supplementary Issue, Pages 205-215, 1992.\n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.Tableaus.TableauRK4","page":"Library","title":"RungeKutta.Tableaus.TableauRK4","text":"Alias for TableauRK416\n\n\n\n\n\n","category":"function"},{"location":"library/#RungeKutta.Tableaus.TableauRK416-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Library","title":"RungeKutta.Tableaus.TableauRK416","text":"Tableau of explicit Runge-Kutta method of order four (1/6 rule)\n\nTableauRK416(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nWilhelm Kutta\nBeitrag zur Näherungsweisen Integration totaler Differentialgleichungen\nZeitschrift für Mathematik und Physik, Volume 46, Pages 435–453, 1901.\nPage 443\n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.Tableaus.TableauRK438-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Library","title":"RungeKutta.Tableaus.TableauRK438","text":"Tableau of explicit Runge-Kutta method of order four (3/8 rule)\n\nTableauRK438(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nWilhelm Kutta\nBeitrag zur Näherungsweisen Integration totaler Differentialgleichungen\nZeitschrift für Mathematik und Physik, Volume 46, Pages 435–453, 1901.\nPage 441\n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.Tableaus.TableauRadauIA-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Library","title":"RungeKutta.Tableaus.TableauRadauIA","text":"Radau IA tableau with s stages\n\nTableauRadauIA(::Type{T}, s)\nTableauRadauIA(s) = TableauRadauIA(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nReferences:\n\nByron Leonard Ehle\nOn Padé approximations to the exponential function and a-stable methods for the numerical solution of initial value problems.\nResearch Report CSRR 2010, Dept. AACS, University of Waterloo, 1969.\n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.Tableaus.TableauRadauIB-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Library","title":"RungeKutta.Tableaus.TableauRadauIB","text":"Radau IB tableau with s stages\n\nTableauRadauIB(::Type{T}, s)\nTableauRadauIB(s) = TableauRadauIB(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nCoefficients are taken as a^B = frac12 ( a^A + bara^A ) where a^A are the coefficients of the Radau IA method and bara^A are computed such that the symplecticity conditions b_i bara_ij + barb_j a_ji = b_i barb_j and b_i = barb_i hold for all 1 le ij le s.\n\nReference:\n\nSun Geng\nConstruction of high order symplectic Runge-Kutta methods\nJournal of Computational Mathematics, Volume 11, Pages 250-260, 1993.\n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.Tableaus.TableauRadauIIA-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Library","title":"RungeKutta.Tableaus.TableauRadauIIA","text":"Radau IIA tableau with s stages\n\nTableauRadauIIA(::Type{T}, s)\nTableauRadauIIA(s) = TableauRadauIIA(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nReferences:\n\nByron Leonard Ehle\nOn Padé approximations to the exponential function and a-stable methods for the numerical solution of initial value problems.\nResearch Report CSRR 2010, Dept. AACS, University of Waterloo, 1969.\n\nOwe Axelsson.\nA class of A-stable methods.\nBIT, Volume 9, Pages 185-199, 1969.\ndoi: 10.1007/BF01946812.\n\nErnst Hairer and Gerhard Wanner.\nRadau Methods.\nIn: Engquist B. (eds). Encyclopedia of Applied and Computational Mathematics. Springer, Berlin, Heidelberg. 2015.\ndoi: 10.1007/978-3-540-70529-1_139.\n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.Tableaus.TableauRadauIIB-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Library","title":"RungeKutta.Tableaus.TableauRadauIIB","text":"Radau IIB tableau with s stages\n\nTableauRadauIIB(::Type{T}, s)\nTableauRadauIIB(s) = TableauRadauIIB(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nCoefficients are taken as a^B = frac12 ( a^A + bara^A ) where a^A are the coefficients of the Radau IIA method and bara^A are computed such that the symplecticity conditions b_i bara_ij + barb_j a_ji = b_i barb_j and b_i = barb_i hold for all 1 le ij le s.\n\nReference:\n\nSun Geng\nConstruction of high order symplectic Runge-Kutta methods\nJournal of Computational Mathematics, Volume 11, Pages 250-260, 1993.\n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.Tableaus.TableauRalston2-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Library","title":"RungeKutta.Tableaus.TableauRalston2","text":"Tableau of Ralston's two-stage, 2nd order method\n\nTableauRalston2(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nAnthony Ralston.\nRunge-Kutta Methods with Minimum Error Bounds.\nMathematics of Computation, Volume 16, Pages 431-437, 1962.\ndoi: 10.1090/S0025-5718-1962-0150954-0.\nEquation (3.5)\n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.Tableaus.TableauRalston3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Library","title":"RungeKutta.Tableaus.TableauRalston3","text":"Tableau of Ralston's three-stage, 3rd order method\n\nTableauRalston3(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nAnthony Ralston.\nRunge-Kutta Methods with Minimum Error Bounds.\nMathematics of Computation, Volume 16, Pages 431-437, 1962.\ndoi: 10.1090/S0025-5718-1962-0150954-0.\nEquation (4.10)\n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.Tableaus.TableauRunge-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Library","title":"RungeKutta.Tableaus.TableauRunge","text":"Tableau of Runge's two-stage, 2nd order method\n\nTableauRunge(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nCarl Runge\nÜber die numerische Auflösung von Differentialgleichungen.\nMathematische Annalen, Volume 46, Pages 167-178, 1895.\ndoi: 10.1007/BF01446807.\nEquation (3)\n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.Tableaus.TableauRunge2","page":"Library","title":"RungeKutta.Tableaus.TableauRunge2","text":"Alias for TableauRunge\n\n\n\n\n\n","category":"function"},{"location":"library/#RungeKutta.Tableaus.TableauSRK3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Library","title":"RungeKutta.Tableaus.TableauSRK3","text":"Tableau of symmetric and symplectic three-stage, 4th order Runge-Kutta method\n\nTableauSRK3(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nShan Zhao and Guo-Wei Wei.\nA unified discontinuous Galerkin framework for time integration.\nMathematical Methods in the Applied Sciences, Volume 37, Issue 7, Pages 1042-1071, 2014.\ndoi: 10.1002/mma.2863.\n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.Tableaus.TableauSSPRK2","page":"Library","title":"RungeKutta.Tableaus.TableauSSPRK2","text":"Tableau of 2rd order Strong Stability Preserving method with two stages and CFL ≤ 1\n\nAlias for TableauHeun2\n\nTableauSSPRK2(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nChi-Wang Shu, Stanley Osher.\nEfficient implementation of essentially non-oscillatory shock-capturing schemes.\nJournal of Computational Physics, Volume 77, Issue 2, Pages 439-471, 1988.\ndoi: 10.1016/0021-9991(88)90177-5.\nEquation (2.16)\n\n\n\n\n\n","category":"function"},{"location":"library/#RungeKutta.Tableaus.TableauSSPRK3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Library","title":"RungeKutta.Tableaus.TableauSSPRK3","text":"Tableau of 3rd order Strong Stability Preserving method with three stages and CFL ≤ 1\n\nTableauSSPRK3(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nChi-Wang Shu, Stanley Osher.\nEfficient implementation of essentially non-oscillatory shock-capturing schemes.\nJournal of Computational Physics, Volume 77, Issue 2, Pages 439-471, 1988.\ndoi: 10.1016/0021-9991(88)90177-5.\nEquation (2.18)\n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.Tableaus.get_gauss_coefficients-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Library","title":"RungeKutta.Tableaus.get_gauss_coefficients","text":"The Gauss coefficients are implicitly given by the so-called simplifying assumption C(s):\n\nsum limits_j=1^s a_ij c_j^k-1 = fracc_i^kk  qquad i = 1      s   k = 1      s \n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.Tableaus.get_gauss_nodes-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Library","title":"RungeKutta.Tableaus.get_gauss_nodes","text":"The Gauss nodes are given by the roots of the shifted Legendre polynomial P_s (2x-1) with s the number of stages.\n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.Tableaus.get_gauss_weights-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Library","title":"RungeKutta.Tableaus.get_gauss_weights","text":"The Gauss weights are given by the following integrals\n\nb_i = bigg( fracdPdx (c_i) bigg)^-2 int limits_0^1 bigg( fracP(x)x - c_i bigg)^2 dx \n\nwhere P(x) denotes the shifted Legendre polynomial P(x) = P_s (2x-1) with s the number of stages.\n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.Tableaus.get_lobatto_a_coefficients-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Library","title":"RungeKutta.Tableaus.get_lobatto_a_coefficients","text":"The Lobatto IIIA coefficients are implicitly given by the so-called simplifying assumption C(s):\n\nsum limits_j=1^s a_ij c_j^k-1 = fracc_i^kk  qquad i = 1      s   k = 1      s \n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.Tableaus.get_lobatto_b_coefficients-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Library","title":"RungeKutta.Tableaus.get_lobatto_b_coefficients","text":"The Lobatto IIIB coefficients are implicitly given by the so-called simplifying assumption D(s):\n\nsum limits_i=1^s b_i c_i^k-1 a_ij = fracb_jk ( 1 - c_j^k)  qquad j = 1      s   k = 1      s \n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.Tableaus.get_lobatto_c_coefficients-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Library","title":"RungeKutta.Tableaus.get_lobatto_c_coefficients","text":"The Lobatto IIIC coefficients are determined by setting a_i1 = b_1 and solving the so-called simplifying assumption C(s-1), given by\n\nsum limits_j=1^s a_ij c_j^k-1 = fracc_i^kk  qquad i = 1      s   k = 1      s-1 \n\nfor a_ij with i = 1  s and j = 2  s.\n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.Tableaus.get_lobatto_c̄_coefficients-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Library","title":"RungeKutta.Tableaus.get_lobatto_c̄_coefficients","text":"The Lobatto IIIC̄ coefficients are determined by setting a_is = 0 and solving the so-called simplifying assumption C(s-1), given by\n\nsum limits_j=1^s a_ij c_j^k-1 = fracc_i^kk  qquad i = 1      s   k = 1      s-1 \n\nfor a_ij with i = 1  s and j = 1  s-1.\n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.Tableaus.get_lobatto_nodes-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Library","title":"RungeKutta.Tableaus.get_lobatto_nodes","text":"The s-stage Lobatto nodes are defined as the roots of the following polynomial of degree s:\n\nfracd^s-2dx^s-2 big( (x - x^2)^s-1 big) \n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.Tableaus.get_lobatto_nullvector-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Library","title":"RungeKutta.Tableaus.get_lobatto_nullvector","text":"get_lobatto_nullvector(::Type, s; normalize=false)\nget_lobatto_nullvector(s; kwargs...)\n\nComputes the nullvector of the matrix containing the derivatives of the Lagrange basis on the s Lobatto nodes evaluated on these nodes.\n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.Tableaus.get_lobatto_weights-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Library","title":"RungeKutta.Tableaus.get_lobatto_weights","text":"The Lobatto weights can be explicitly computed by the formula\n\nb_j = frac1s (s-1) P_s-1(2 c_j - 1)^2 qquad j = 1      s \n\nwhere P_k is the kth Legendre polynomial, given by\n\nP_k (x) = frac1k 2^k big( fracd^kdx^k (x^2 - 1)^k big) \n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.Tableaus.get_radau_1_coefficients-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Library","title":"RungeKutta.Tableaus.get_radau_1_coefficients","text":"The Radau IA coefficients are implicitly given by the so-called simplifying assumption D(s):\n\nsum limits_i=1^s b_i c_i^k-1 a_ij = fracb_jk ( 1 - c_j^k)  qquad j = 1      s   k = 1      s \n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.Tableaus.get_radau_1_nodes-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Library","title":"RungeKutta.Tableaus.get_radau_1_nodes","text":"The s-stage Radau IA nodes are defined as the roots of the following polynomial of degree s:\n\nfracd^s-1dx^s-1 big( x^s (x - 1)^s-1 big) \n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.Tableaus.get_radau_1_weights-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Library","title":"RungeKutta.Tableaus.get_radau_1_weights","text":"The Radau IA weights are implicitly given by the so-called simplifying assumption B(s):\n\nsum limits_j=1^s b_j c_j^k-1 = frac1k  qquad k = 1      s \n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.Tableaus.get_radau_2_coefficients-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Library","title":"RungeKutta.Tableaus.get_radau_2_coefficients","text":"The Radau IIA coefficients are implicitly given by the so-called simplifying assumption C(s):\n\nsum limits_j=1^s a_ij c_j^k-1 = fracc_i^kk  qquad i = 1      s   k = 1      s \n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.Tableaus.get_radau_2_nodes-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Library","title":"RungeKutta.Tableaus.get_radau_2_nodes","text":"The s-stage Radau IIA nodes are defined as the roots of the following polynomial of degree s:\n\nfracd^s-1dx^s-1 big( x^s-1 (x - 1)^s big) \n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.Tableaus.get_radau_2_weights-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Library","title":"RungeKutta.Tableaus.get_radau_2_weights","text":"The Radau IIA weights are implicitly given by the so-called simplifying assumption B(s):\n\nsum limits_j=1^s b_j c_j^k-1 = frac1k  qquad k = 1      s \n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.PartitionedTableaus.PartitionedTableauGauss-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T","page":"Library","title":"RungeKutta.PartitionedTableaus.PartitionedTableauGauss","text":"Partitioned Gauss-Legendre Runge-Kutta tableau with s stages\n\nPartitionedTableauGauss(::Type{T}, s)\nPartitionedTableauGauss(s) = PartitionedTableauGauss(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nThis PartitionedTableau uses TableauGauss for both coefficients a and ā.\n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.PartitionedTableaus.TableauLobattoIIIAIIIB-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T","page":"Library","title":"RungeKutta.PartitionedTableaus.TableauLobattoIIIAIIIB","text":"Partitioned Gauss-Lobatto IIIA-IIIB tableau with s stages\n\nTableauLobattoIIIAIIIB(::Type{T}, s)\nTableauLobattoIIIAIIIB(s) = TableauLobattoIIIAIIIB(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nThis PartitionedTableau uses TableauLobattoIIIA for a and TableauLobattoIIIB for ā.\n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.PartitionedTableaus.TableauLobattoIIIAIIIĀ-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T","page":"Library","title":"RungeKutta.PartitionedTableaus.TableauLobattoIIIAIIIĀ","text":"Tableau for Gauss-Lobatto IIIA-IIIĀ method with s stages\n\nTableauLobattoIIIAIIIĀ(::Type{T}, s)\nTableauLobattoIIIAIIIĀ(s) = TableauLobattoIIIAIIIĀ(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nThis PartitionedTableau uses TableauLobattoIIIA for a and TableauLobattoIIIĀ for ā.\n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.PartitionedTableaus.TableauLobattoIIIBIIIA-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T","page":"Library","title":"RungeKutta.PartitionedTableaus.TableauLobattoIIIBIIIA","text":"Tableau for Gauss-Lobatto IIIB-IIIA method with s stages\n\nTableauLobattoIIIBIIIA(::Type{T}, s)\nTableauLobattoIIIBIIIA(s) = TableauLobattoIIIBIIIA(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nThis PartitionedTableau uses TableauLobattoIIIB for a and TableauLobattoIIIA for ā.\n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.PartitionedTableaus.TableauLobattoIIIBIIIB̄-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T","page":"Library","title":"RungeKutta.PartitionedTableaus.TableauLobattoIIIBIIIB̄","text":"Tableau for Gauss-Lobatto IIIB-IIIB̄ method with s stages\n\nTableauLobattoIIIBIIIB̄(::Type{T}, s)\nTableauLobattoIIIBIIIB̄(s) = TableauLobattoIIIBIIIB̄(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nThis PartitionedTableau uses TableauLobattoIIIB for a and TableauLobattoIIIB̄ for ā.\n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.PartitionedTableaus.TableauLobattoIIICIIIC̄-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T","page":"Library","title":"RungeKutta.PartitionedTableaus.TableauLobattoIIICIIIC̄","text":"Tableau for Gauss-Lobatto IIIC-IIIC̄ method with s stages\n\nTableauLobattoIIICIIIC̄(::Type{T}, s)\nTableauLobattoIIICIIIC̄(s) = TableauLobattoIIICIIIC̄(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nThis PartitionedTableau uses TableauLobattoIIIC for a and TableauLobattoIIIC̄ for ā.\n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.PartitionedTableaus.TableauLobattoIIIC̄IIIC-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T","page":"Library","title":"RungeKutta.PartitionedTableaus.TableauLobattoIIIC̄IIIC","text":"Tableau for Gauss-Lobatto IIIC̄-IIIC method with s stages\n\nTableauLobattoIIIC̄IIIC(::Type{T}, s)\nTableauLobattoIIIC̄IIIC(s) = TableauLobattoIIIC̄IIIC(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nThis PartitionedTableau uses TableauLobattoIIIC̄ for a and TableauLobattoIIIC for ā.\n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.PartitionedTableaus.TableauLobattoIIIDIIID̄-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T","page":"Library","title":"RungeKutta.PartitionedTableaus.TableauLobattoIIIDIIID̄","text":"Tableau for Gauss-Lobatto IIID-IIID̄ method with s stages\n\nTableauLobattoIIIDIIID̄(::Type{T}, s)\nTableauLobattoIIIDIIID̄(s) = TableauLobattoIIIDIIID̄(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nThis PartitionedTableau uses TableauLobattoIIID for a and TableauLobattoIIID̄ for ā.\n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.PartitionedTableaus.TableauLobattoIIIEIIIĒ-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T","page":"Library","title":"RungeKutta.PartitionedTableaus.TableauLobattoIIIEIIIĒ","text":"Tableau for Gauss-Lobatto IIIE-IIIĒ method with s stages\n\nTableauLobattoIIIEIIIĒ(::Type{T}, s)\nTableauLobattoIIIEIIIĒ(s) = TableauLobattoIIIEIIIĒ(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nThis PartitionedTableau uses TableauLobattoIIIE for a and TableauLobattoIIIĒ for ā.\n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.PartitionedTableaus.TableauLobattoIIIFIIIF̄-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T","page":"Library","title":"RungeKutta.PartitionedTableaus.TableauLobattoIIIFIIIF̄","text":"Tableau for Gauss-Lobatto IIIF-IIIF̄ method with s stages\n\nTableauLobattoIIIFIIIF̄(::Type{T}, s)\nTableauLobattoIIIFIIIF̄(s) = TableauLobattoIIIFIIIF̄(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nThis PartitionedTableau uses TableauLobattoIIIF for a and TableauLobattoIIIF̄ for ā.\n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.PartitionedTableaus.TableauLobattoIIIF̄IIIF-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T","page":"Library","title":"RungeKutta.PartitionedTableaus.TableauLobattoIIIF̄IIIF","text":"Tableau for Gauss-Lobatto IIIF̄-IIIF method with s stages\n\nTableauLobattoIIIF̄IIIF(::Type{T}, s)\nTableauLobattoIIIF̄IIIF(s) = TableauLobattoIIIF̄IIIF(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nThis PartitionedTableau uses TableauLobattoIIIF̄ for a and TableauLobattoIIIF for ā.\n\n\n\n\n\n","category":"method"},{"location":"library/#RungeKutta.PartitionedTableaus.TableauLobattoIIIGIIIḠ-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T","page":"Library","title":"RungeKutta.PartitionedTableaus.TableauLobattoIIIGIIIḠ","text":"Tableau for Gauss-Lobatto IIIG-IIIḠ method with s stages\n\nTableauLobattoIIIGIIIḠ(::Type{T}, s)\nTableauLobattoIIIGIIIḠ(s) = TableauLobattoIIIGIIIḠ(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nThis PartitionedTableau uses TableauLobattoIIIG for a and TableauLobattoIIIḠ for ā.\n\n\n\n\n\n","category":"method"},{"location":"tableau/","page":"Tableau","title":"Tableau","text":"CurrentModule = RungeKutta","category":"page"},{"location":"tableau/#Tableau","page":"Tableau","title":"Tableau","text":"","category":"section"},{"location":"tableau/","page":"Tableau","title":"Tableau","text":"The Tableau type is the main data structure in RungeKutta.jl. It holds all the coeffieints and information on a Runge-Kutta method in the form of a so-called Butcher tableau","category":"page"},{"location":"tableau/","page":"Tableau","title":"Tableau","text":"beginarraycc\nc  a     \nhline\n   b^T \nendarray\n=\nbeginarrayccccc\nc_1   a_11  a_12  dots  a_1s \nc_2   a_21  a_22  dots  a_2s \nvdots  vdots  vdots  ddots  vdots \nc_s   a_s1  a_s2  dots  a_ss \nhline\n        b_1   b_2   dots  b_s  \nendarray","category":"page"},{"location":"tableau/","page":"Tableau","title":"Tableau","text":"The Tableau type has the following fields:","category":"page"},{"location":"tableau/","page":"Tableau","title":"Tableau","text":"name is a descriptive name of the tableau,\no the order of the method,\ns the number of stages,\na the coefficients,\nb the weights,\nc the nodes.","category":"page"},{"location":"tableau/","page":"Tableau","title":"Tableau","text":"Although one of the main goals of RungeKutta.jl is to provide as many known tableaus as possible (see below), it is straight-forward to create a custom tableau. The tableau of Heun's method, for example, is defined as follows:","category":"page"},{"location":"tableau/","page":"Tableau","title":"Tableau","text":"a = [[0.0  0.0]\n     [1.0  0.0]]\nb =  [0.5, 0.5]\nc =  [0.0, 1.0]\no = 2\n\ntab = Tableau(:heun, o, a, b, c)","category":"page"},{"location":"tableau/","page":"Tableau","title":"Tableau","text":"There exist several constructors","category":"page"},{"location":"tableau/","page":"Tableau","title":"Tableau","text":"Tableau{T}(name, o, s, a, b, c)\nTableau{T}(name, o, a, b, c)\nTableau(name,o, s, a, b, c)\nTableau(name,o, a, b, c)","category":"page"},{"location":"tableau/","page":"Tableau","title":"Tableau","text":"The meaning of the arguments corresponds to the fields as explained above and T is the datatype of the coefficient arrays. If s is ommitted it is inferred from the length of c. All coefficient arrays are checked for compatible sizes. If T is not specified, the datatype is inferred from the type of a, b and c, which are then assumed to be identical. If T is specified and does not correspond to the types of  a, b and c, the arrays are converted accordingly.","category":"page"},{"location":"tableau/#Tabulated-Coefficients","page":"Tableau","title":"Tabulated Coefficients","text":"","category":"section"},{"location":"tableau/","page":"Tableau","title":"Tableau","text":"RungeKutta.jl provides tabulated coefficients for various explicit and implicit (both diagonally and fully implicit) Runge-Kutta methods, in particular","category":"page"},{"location":"tableau/","page":"Tableau","title":"Tableau","text":"Function and Aliases Stages Order\nExplicit Methods  \nTableauExplicitEuler, TableauForwardEuler 1 1\nTableauExplicitMidpoint 2 2\nTableauHeun2 2 2\nTableauHeun3 3 3\nTableauRalston2 2 2\nTableauRalston3 3 3\nTableauRunge, TableauRunge2 2 2\nTableauKutta, TableauKutta3 3 3\nTableauRK416, TableauRK4 4 4\nTableauRK438 4 4\nTableauSSPRK3 3 3\nDiagonally Implicit Methods  \nTableauCrankNicolson 2 2\nTableauKraaijevangerSpijker 2 2\nTableauQinZhang 2 2\nTableauCrouzeix 2 3\nFully Implicit Methods  \nTableauImplicitEuler, TableauBackwardEuler 1 1\nTableauImplicitMidpoint 2 2\nTableauSRK3 3 4","category":"page"},{"location":"tableau/","page":"Tableau","title":"Tableau","text":"All constructors take an optional type argument, defaulting to Float64.","category":"page"},{"location":"tableau/#Gauß,-Lobatto-and-Radau-Methods","page":"Tableau","title":"Gauß, Lobatto and Radau Methods","text":"","category":"section"},{"location":"tableau/","page":"Tableau","title":"Tableau","text":"The coefficients of the Gauß, Lobatto and Radau methods are computed on-the-fly by the following constructors:","category":"page"},{"location":"tableau/","page":"Tableau","title":"Tableau","text":"Function Method Order\nTableauGauss(T, s) Gauß with s stages 2s\nTableauLobattoIIIA(T, s) Lobatto IIIA with s stages 2s-2\nTableauLobattoIIIB(T, s) Lobatto IIIB with s stages 2s-2\nTableauLobattoIIIC(T, s) Lobatto IIIC with s stages 2s-2\nTableauLobattoIIIC̄(T, s) Lobatto IIIC̄ with s stages 2s-2\nTableauLobattoIIID(T, s) Lobatto IIID with s stages 2s-2\nTableauLobattoIIIE(T, s) Lobatto IIIE with s stages 2s-2\nTableauLobattoIIIF(T, s) Lobatto IIIF with s stages 2s\nTableauLobattoIIIG(T, s) Lobatto IIIG with s stages 2s\nTableauRadauIA(T, s) Radau IA with s stages 2s-1\nTableauRadauIIA(T, s) Radau IIA with s stages 2s-1","category":"page"},{"location":"tableau/","page":"Tableau","title":"Tableau","text":"The first argument specifies the number type of the coefficients. Internally, all coefficients are computed using BigFloat and then converted to the requested number type, defaulting to Float64. The second argument s refers to the number of stages (s ge 1 for Gauß and s ge 2 for all other methods). The type specifier can also be ommitted.","category":"page"},{"location":"gauss/#Gauss-Legendre-Runge-Kutta-Methods","page":"Gauß Methods","title":"Gauss-Legendre Runge-Kutta Methods","text":"","category":"section"},{"location":"gauss/","page":"Gauß Methods","title":"Gauß Methods","text":"Runge-Kutta Tableau Gauss(1) with 1 stages and order 2: Error: TypeError: in keyword argument backend, expected Union{Val{:auto}, Val{:text}, Val{:html}, Val{:latex}}, got a value of type Symbol","category":"page"},{"location":"bibliography/#Bibliography","page":"Bibliography","title":"Bibliography","text":"","category":"section"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = RungeKutta","category":"page"},{"location":"#Runge-Kutta","page":"Home","title":"Runge Kutta","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: PkgEval Status) (Image: Build Status) (Image: Coverage) (Image: DOI)","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package collects Runge-Kutta tableaus and provides diagnostics to analyze them. It implements algorithms for the computation of Gauss, Lobatto and Radau tableaus with arbitrary numbers of stages as well as tabulated coefficients for various explicit, diagonally implicit and fully implicit methods. All tableaus can be retrieved in arbitrary precision.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"RungeKutta.jl and all of its dependencies can be installed via the Julia REPL by typing ","category":"page"},{"location":"","page":"Home","title":"Home","text":"]add RungeKutta","category":"page"},{"location":"#Basic-Usage","page":"Home","title":"Basic Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"After loading the Runge-Kutta module by","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using RungeKutta","category":"page"},{"location":"","page":"Home","title":"Home","text":"a Tableau can be created by calling any one of the provided constructors, for example","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> TableauExplicitMidpoint()\n\nRunge-Kutta Tableau explicit_midpoint with 2 stages and order 2:\n\n 0.0 │ 0.0  0.0\n 0.5 │ 0.5  0.0\n─────┼──────────\n     │ 0.0  1.0","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Tableau type has the following fields","category":"page"},{"location":"","page":"Home","title":"Home","text":"name is a descriptive name of the tableau,\no the order of the method,\ns the number of stages,\na the coefficients,\nb the weights,\nc the nodes.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The following tableaus are implemented (prepend Tableau to the name to call the respective constructor):","category":"page"},{"location":"","page":"Home","title":"Home","text":"explicit: ExplicitEuler/ForwardEuler, ExplicitMidpoint, Heun2, Heun3, Ralston2, Ralston3, Runge/Runge2, Kutta/Kutta3, RK4/RK416, RK438, SSPRK3\ndiagonally implicit: KraaijevangerSpijker, QinZhang, Crouzeix\nfully implicit: ImplicitEuler/BackwardEuler, ImplicitMidpoint, CrankNicolson, SRK3","category":"page"},{"location":"","page":"Home","title":"Home","text":"In addition there exist functions to compute Gauss, Lobatto and Radau tableaus with an arbitrary number of stages s:","category":"page"},{"location":"","page":"Home","title":"Home","text":"TableauGauss(s)\nTableauLobattoIIIA(s), TableauLobattoIIIB(s), TableauLobattoIIIC(s), TableauLobattoIIIC̄(s), TableauLobattoIIID(s), TableauLobattoIIIE(s), TableauLobattoIIIF(s), TableauLobattoIIIG(s)\nTableauRadauIA(s), TableauRadauIIA(s)","category":"page"},{"location":"","page":"Home","title":"Home","text":"All constructors take an optional type argument T, as in TableauExplicitMidpoint(T) or TableauGauss(T,s). The default type is Float64, but it can be set to other number types if needed, e.g., to Float32 for single precision or to the Dec128 type from DecFP.jl for quadruple precision. Internally, all tableaus are computed using BigFloat, providing high-accuracy coefficients as they are required for simulations in quadruple or higher precision. The internal precision can be set via setprecision(40), cf. the Julia Manual on Arbitrary Precision Arithmetic.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use RungeKutta.jl in your work, please consider citing it by","category":"page"},{"location":"","page":"Home","title":"Home","text":"@misc{Kraus:2020:RungeKutta,\n  title={RungeKutta.jl: Runge-Kutta Methods in Julia},\n  author={Kraus, Michael},\n  year={2020},\n  howpublished={\\url{https://github.com/JuliaGNI/RungeKutta.jl}},\n  doi={10.5281/zenodo.4294923}\n}","category":"page"},{"location":"lobatto/#Lobatto-III-Runge-Kutta-Methods","page":"Lobatto III Methods","title":"Lobatto III Runge-Kutta Methods","text":"","category":"section"},{"location":"lobatto/#Lobatto-IIIA","page":"Lobatto III Methods","title":"Lobatto IIIA","text":"","category":"section"},{"location":"lobatto/","page":"Lobatto III Methods","title":"Lobatto III Methods","text":"Runge-Kutta Tableau LobattoIIIA(2) with 2 stages and order 2: Error: TypeError: in keyword argument backend, expected Union{Val{:auto}, Val{:text}, Val{:html}, Val{:latex}}, got a value of type Symbol","category":"page"},{"location":"lobatto/#Lobatto-IIIB","page":"Lobatto III Methods","title":"Lobatto IIIB","text":"","category":"section"},{"location":"lobatto/","page":"Lobatto III Methods","title":"Lobatto III Methods","text":"Runge-Kutta Tableau LobattoIIIB(2) with 2 stages and order 2: Error: TypeError: in keyword argument backend, expected Union{Val{:auto}, Val{:text}, Val{:html}, Val{:latex}}, got a value of type Symbol","category":"page"},{"location":"lobatto/#Lobatto-IIIC","page":"Lobatto III Methods","title":"Lobatto IIIC","text":"","category":"section"},{"location":"lobatto/","page":"Lobatto III Methods","title":"Lobatto III Methods","text":"Runge-Kutta Tableau LobattoIIIC(2) with 2 stages and order 2: Error: TypeError: in keyword argument backend, expected Union{Val{:auto}, Val{:text}, Val{:html}, Val{:latex}}, got a value of type Symbol","category":"page"},{"location":"lobatto/#Lobatto-IIIC-2","page":"Lobatto III Methods","title":"Lobatto IIIC̄","text":"","category":"section"},{"location":"lobatto/","page":"Lobatto III Methods","title":"Lobatto III Methods","text":"Runge-Kutta Tableau LobattoIIIC̄(2) with 2 stages and order 2: Error: TypeError: in keyword argument backend, expected Union{Val{:auto}, Val{:text}, Val{:html}, Val{:latex}}, got a value of type Symbol","category":"page"},{"location":"lobatto/#Lobatto-IIID","page":"Lobatto III Methods","title":"Lobatto IIID","text":"","category":"section"},{"location":"lobatto/","page":"Lobatto III Methods","title":"Lobatto III Methods","text":"Runge-Kutta Tableau LobattoIIID(2) with 2 stages and order 2: Error: TypeError: in keyword argument backend, expected Union{Val{:auto}, Val{:text}, Val{:html}, Val{:latex}}, got a value of type Symbol","category":"page"},{"location":"lobatto/#Lobatto-IIIE","page":"Lobatto III Methods","title":"Lobatto IIIE","text":"","category":"section"},{"location":"lobatto/","page":"Lobatto III Methods","title":"Lobatto III Methods","text":"Runge-Kutta Tableau LobattoIIIE(2) with 2 stages and order 2: Error: TypeError: in keyword argument backend, expected Union{Val{:auto}, Val{:text}, Val{:html}, Val{:latex}}, got a value of type Symbol","category":"page"},{"location":"lobatto/#Lobatto-IIIF","page":"Lobatto III Methods","title":"Lobatto IIIF","text":"","category":"section"},{"location":"lobatto/","page":"Lobatto III Methods","title":"Lobatto III Methods","text":"Runge-Kutta Tableau LobattoIIIF(2) with 2 stages and order 4: Error: TypeError: in keyword argument backend, expected Union{Val{:auto}, Val{:text}, Val{:html}, Val{:latex}}, got a value of type Symbol","category":"page"},{"location":"lobatto/#Lobatto-IIIG","page":"Lobatto III Methods","title":"Lobatto IIIG","text":"","category":"section"},{"location":"lobatto/","page":"Lobatto III Methods","title":"Lobatto III Methods","text":"Runge-Kutta Tableau LobattoIIIG(2) with 2 stages and order 4: Error: TypeError: in keyword argument backend, expected Union{Val{:auto}, Val{:text}, Val{:html}, Val{:latex}}, got a value of type Symbol","category":"page"}]
}
